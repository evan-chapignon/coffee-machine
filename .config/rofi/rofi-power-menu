#!/usr/bin/env bash
set -e
set -u

# Toutes les options prises en charge
all=(shutdown reboot suspend hibernate logout lockscreen)

# Par défaut, tout afficher (c’est-à-dire, copier simplement le tableau)
show=("${all[@]}")

declare -A texts
texts[lockscreen]="lock screen"
texts[switchuser]="switch user"
texts[logout]="log out"
texts[suspend]="suspend"
texts[hibernate]="hibernate"
texts[reboot]="reboot"
texts[shutdown]="shut down"

declare -A icons
icons[lockscreen]="\uf023"
icons[switchuser]="\uf518"
icons[logout]="\uf842"
icons[suspend]="\uf9b1"
icons[hibernate]="\uf7c9"
icons[reboot]="\ufc07"
icons[shutdown]="\uf011"
icons[cancel]="\u00d7"

declare -A actions
actions[lockscreen]="loginctl lock-session ${XDG_SESSION_ID-}"
#actions[switchuser]="???"
actions[logout]="loginctl terminate-session ${XDG_SESSION_ID-}"
actions[suspend]="systemctl suspend"
actions[hibernate]="systemctl hibernate"
actions[reboot]="systemctl reboot"
actions[shutdown]="systemctl poweroff"

# Par défaut, demander confirmation pour les actions irréversibles
confirmations=(reboot shutdown logout)

# Par défaut, pas de mode simulation
dryrun=false
showsymbols=true

function check_valid {
    option="$1"
    shift 1
    for entry in "${@}"
    do
        if [ -z "${actions[$entry]+x}" ]
        then
            echo "Choix invalide dans $1: $entry" >&2
            exit 1
        fi
    done
}

# Analyse des options de ligne de commande
parsed=$(getopt --options=h --longoptions=help,dry-run,confirm:,choices:,choose:,symbols,no-symbols --name "$0" -- "$@")
if [ $? -ne 0 ]; then
    echo 'Arrêt du script...' >&2
    exit 1
fi
eval set -- "$parsed"
unset parsed
while true; do
    case "$1" in
        "-h"|"--help")
            echo "rofi-power-menu - un mode menu d’alimentation pour Rofi"
            echo
            echo "Utilisation : rofi-power-menu [--choices CHOIX] [--confirm CHOIX]"
            echo "                               [--choose CHOIX] [--dry-run] [--symbols|--no-symbols]"
            echo
            echo "À utiliser avec Rofi en mode script. Par exemple, pour demander arrêt ou redémarrage :"
            echo
            echo "  rofi -show menu -modi \"menu:rofi-power-menu --choices=shutdown/reboot\""
            echo
            echo "Options disponibles :"
            echo "  --dry-run          Ne pas exécuter l’action sélectionnée mais l’afficher sur stderr."
            echo "  --choices CHOIX    Afficher uniquement les choix sélectionnés dans l’ordre donné."
            echo "                     Utiliser / comme séparateur. Choix disponibles : lockscreen,"
            echo "                     logout, suspend, hibernate, reboot et shutdown. Par défaut,"
            echo "                     tous les choix disponibles sont affichés."
            echo "  --confirm CHOIX    Demander confirmation uniquement pour les choix donnés."
            echo "                     Utiliser / comme séparateur. Choix disponibles : lockscreen,"
            echo "                     logout, suspend, hibernate, reboot et shutdown. Par défaut,"
            echo "                     seules les actions irréversibles logout, reboot et shutdown"
            echo "                     nécessitent une confirmation."
            echo "  --choose CHOIX     Préselectionner le choix donné et ne demander qu’une confirmation"
            echo "                     (si elle est configurée). Il est fortement recommandé de combiner"
            echo "                     cette option avec --confirm=CHOIX si l’action ne demande pas"
            echo "                     de confirmation par défaut. Choix disponibles : lockscreen,"
            echo "                     logout, suspend, hibernate, reboot et shutdown."
            echo "  --[no-]symbols     Afficher ou non les symboles Unicode. Nécessite une police"
            echo "                     compatible (par ex. celles de la collection Nerdfonts)."
            echo "                     Par défaut, ils sont affichés."
            echo "  -h,--help          Afficher ce texte d’aide."
            exit 0
            ;;
        "--dry-run")
            dryrun=true
            shift 1
            ;;
        "--confirm")
            IFS='/' read -ra confirmations <<< "$2"
            check_valid "$1" "${confirmations[@]}"
            shift 2
            ;;
        "--choices")
            IFS='/' read -ra show <<< "$2"
            check_valid "$1" "${show[@]}"
            shift 2
            ;;
        "--choose")
            # Vérifier que le choix est valide
            check_valid "$1" "$2"
            selectionID="$2"
            shift 2
            ;;
        "--symbols")
            showsymbols=true
            shift 1
            ;;
        "--no-symbols")
            showsymbols=false
            shift 1
            ;;
        "--")
            shift
            break
            ;;
        *)
            echo "Erreur interne" >&2
            exit 1
            ;;
    esac
done

# Définir les messages après l’analyse des options de la CLI afin qu’ils puissent
# être configurés à l’avenir.

function write_message {
    icon="<span font_size=\"medium\">$1</span>"
    text="<span font_size=\"medium\">$2</span>"
    if [ "$showsymbols" = "true" ]
    then
        echo -n "\u200e$icon \u2068$text\u2069"
    else
        echo -n "$text"
    fi
}

function print_selection {
    echo -e "$1" | $(read -r -d '' entry; echo "echo $entry")
}

declare -A messages
declare -A confirmationMessages
for entry in "${all[@]}"
do
    messages[$entry]=$(write_message "${icons[$entry]}" "${texts[$entry]^}")
done
for entry in "${all[@]}"
do
    confirmationMessages[$entry]=$(write_message "${icons[$entry]}" "Yes, ${texts[$entry]}")
done
confirmationMessages[cancel]=$(write_message "${icons[cancel]}" "No, cancel")

if [ $# -gt 0 ]
then
    # Si des arguments sont donnés, les utiliser comme sélection
    selection="${@}"
else
    # Sinon, utiliser le choix passé en ligne de commande s’il existe
    if [ -n "${selectionID+x}" ]
    then
        selection="${messages[$selectionID]}"
    fi
fi

# Ne pas autoriser les entrées personnalisées
echo -e "\0no-custom\x1ftrue"
# Utiliser le balisage
echo -e "\0markup-rows\x1ftrue"

if [ -z "${selection+x}" ]
then
    echo -e "\0prompt\x1fPower menu"
    for entry in "${show[@]}"
    do
        echo -e "${messages[$entry]}\0icon\x1f${icons[$entry]}"
    done
else
    for entry in "${show[@]}"
    do
        if [ "$selection" = "$(print_selection "${messages[$entry]}")" ]
        then
            # Vérifier si l’entrée sélectionnée figure dans les confirmations requises
            for confirmation in "${confirmations[@]}"
            do
                if [ "$entry" = "$confirmation" ]
                then
                    # Demander une confirmation
                    echo -e "\0prompt\x1fAre you sure"
                    echo -e "${confirmationMessages[$entry]}\0icon\x1f${icons[$entry]}"
                    echo -e "${confirmationMessages[cancel]}\0icon\x1f${icons[cancel]}"
                    exit 0
                fi
            done
            # Si non, aucune confirmation n’est requise, donc marquer comme confirmé
            selection=$(print_selection "${confirmationMessages[$entry]}")
        fi
        if [ "$selection" = "$(print_selection "${confirmationMessages[$entry]}")" ]
        then
            if [ $dryrun = true ]
            then
                # Indiquer ce qui aurait été fait
                echo "Sélectionné : $entry" >&2
            else
                # Exécuter l’action
                ${actions[$entry]}
            fi
            exit 0
        fi
        if [ "$selection" = "$(print_selection "${confirmationMessages[cancel]}")" ]
        then
            # Ne rien faire
            exit 0
        fi
    done
    # La sélection ne correspond à rien, donc afficher une erreur
    echo "Sélection invalide : $selection" >&2
    exit 1
fi