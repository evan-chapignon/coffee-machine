* Rofi pour les nuls
Tous persone productive qui ce respecte a sont lanceur d’applications.

* Introduction
 Dans notre configuration on vous a choisie rofi, qui un est un lanceur d’applications et un menu interactif moderne.

** Les polices (fonts)
Nous utilisons la police *Iosevka Nerd*. Pensez donc à l'installer si ce n'est pas déjà fait.  
Un guide d'installation est disponible : [[file:../../README.org::#install-iosevka-font][Installation de Iosevka]]

* Configuration du thème
Cette configuration définit le thème général, les couleurs et le style des différents éléments d'une interface (probablement pour un launcher ou un panel).

** Police et couleurs globales
#+BEGIN_SRC css
  *{
      font: "Iosevka Nerd Font 10";

      /* Couleurs principales */
      foreground: #ebdbb2;           ;; Couleur du texte
      background: #282828;           ;; Couleur de fond générale

      active-background: #282828;    ;; Fond d'un élément actif
      urgent-background: #cc241d;    ;; Fond d'un élément urgent (attention, typo ici)

      selected-background: #ebdbb2;  ;; Fond d'un élément sélectionné
      selected-urgent-background: #ebdbb2;
      selected-active-background: #ebdbb2; ;; Typo ici aussi

      bordercolor: #ebdbb2;          ;; Couleur des bordures
      separatorcolor: #ebdbb2;       ;; Couleur des séparateurs
  }
#+END_SRC

** Fenêtre principale
Le conteneur principal (#window) et ses marges et bordures.
#+BEGIN_SRC css
#window {
    background-color: @background; ;; Fond principal de la fenêtre
    border: 2;                     ;; Épaisseur de la bordure
    border-color: @bordercolor;    ;; Couleur de la bordure
    padding: 10;                   ;; Marge interne
}
#+END_SRC

** Conteneurs internes
- #mainbox : conteneur principal sans bordure ni padding
- #message : zone de message sans bordure
- #textbox : zone de texte avec padding et couleur du texte
- #listview : liste des éléments avec configuration des lignes et scrollbar

#+BEGIN_SRC css
#mainbox {
    border: 0;
    padding: 0;
}

#message {
    border: 0px;
}

#textbox {
    text-color: @foreground;
    padding: 25px;
}

#listview {
    fixed-height: 0;
    lines: 6;          ;; nombre de lignes visibles
    border: 0px;
    spacing: 0px;
    scrollbar: false;  ;; pas de barre de défilement
    padding: 0px;
}
#+END_SRC

** Éléments de la liste (#element)
Chaque élément a un padding, et ses styles dépendent de son état : normal, actif, urgent, sélectionné, ou alterné.

#+BEGIN_SRC css
#element {
    padding: 10px;
}

/* État normal */
#element.normal.normal {background-color: @background; text-color: @foreground;}
#element.normal.active {background-color: @background; text-color: @foreground;}
#element.normal.urgent {background-color: @background; text-color: @foreground;}

/* État sélectionné */
#element.selected.normal {background-color: @selected-background; text-color: @background;}
#element.selected.urgent {background-color: @selected-background; text-color: @background;}
#element.selected.active {background-color: @selected-background; text-color: @background;}

/* État alterné (zebra stripes) */
#element.alternate.normal {background-color: @background; text-color: @foreground;}
#element.alternate.active {background-color: @background; text-color: @foreground;}
#element.alternate.urgent {background-color: @background; text-color: @foreground;}
#+END_SRC

** Barre d'entrée (#inputbar)
Zone de saisie avec espacement et couleur du texte

#+BEGIN_SRC css
  #inputbar {
      spacing: 0;
      text-color: @foreground;
      padding: 5px;
  }
#+END_SRC

* En plus de la configuration : un menu d’alimentation
En plus du thème et du lanceur d’applications, nous ajoutons un **script de menu d’alimentation** pour *Rofi*.  
Ce script permet d’accéder rapidement à des actions système comme éteindre, redémarrer, suspendre ou verrouiller l’écran, le tout depuis une interface élégante.

** Présentation
Le script *rofi-power-menu* ajoute un nouveau mode à Rofi appelé `powermenu`.  
Il s’intègre directement à la commande Rofi sans avoir besoin de modifier sa configuration interne.

Exemple d’appel :
#+BEGIN_SRC bash
rofi -show powermenu -modi powermenu:~/.config/rofi/scripts/rofi-power-menu
#+END_SRC

** Fonctionnalités
- Affiche un menu avec les actions : *verrouiller*, *déconnexion*, *suspendre*, *hiberner*, *redémarrer* et *éteindre*  
- Icônes compatibles avec les polices *Nerd Font*  
- Demande une confirmation avant les actions critiques (redémarrage, arrêt, déconnexion)  
- Option “dry-run” pour tester sans exécuter  
- Mode flexible : peut être intégré dans n’importe quelle configuration Rofi

** Script complet
#+BEGIN_SRC bash
set -e
set -u

# Toutes les options prises en charge
all=(shutdown reboot suspend hibernate logout lockscreen)

# Par défaut, tout afficher (c’est-à-dire, copier simplement le tableau)
show=("${all[@]}")

declare -A texts
texts[lockscreen]="lock screen"
texts[switchuser]="switch user"
texts[logout]="log out"
texts[suspend]="suspend"
texts[hibernate]="hibernate"
texts[reboot]="reboot"
texts[shutdown]="shut down"

declare -A icons
icons[lockscreen]="\uf023"
icons[switchuser]="\uf518"
icons[logout]="\uf842"
icons[suspend]="\uf9b1"
icons[hibernate]="\uf7c9"
icons[reboot]="\ufc07"
icons[shutdown]="\uf011"
icons[cancel]="\u00d7"

declare -A actions
actions[lockscreen]="loginctl lock-session ${XDG_SESSION_ID-}"
#actions[switchuser]="???"
actions[logout]="loginctl terminate-session ${XDG_SESSION_ID-}"
actions[suspend]="systemctl suspend"
actions[hibernate]="systemctl hibernate"
actions[reboot]="systemctl reboot"
actions[shutdown]="systemctl poweroff"

# Par défaut, demander confirmation pour les actions irréversibles
confirmations=(reboot shutdown logout)

# Par défaut, pas de mode simulation
dryrun=false
showsymbols=true

function check_valid {
    option="$1"
    shift 1
    for entry in "${@}"
    do
        if [ -z "${actions[$entry]+x}" ]
        then
            echo "Choix invalide dans $1: $entry" >&2
            exit 1
        fi
    done
}

# Analyse des options de ligne de commande
parsed=$(getopt --options=h --longoptions=help,dry-run,confirm:,choices:,choose:,symbols,no-symbols --name "$0" -- "$@")
if [ $? -ne 0 ]; then
    echo 'Arrêt du script...' >&2
    exit 1
fi
eval set -- "$parsed"
unset parsed
while true; do
    case "$1" in
        "-h"|"--help")
            echo "rofi-power-menu - un mode menu d’alimentation pour Rofi"
            echo
            echo "Utilisation : rofi-power-menu [--choices CHOIX] [--confirm CHOIX]"
            echo "                               [--choose CHOIX] [--dry-run] [--symbols|--no-symbols]"
            echo
            echo "À utiliser avec Rofi en mode script. Par exemple, pour demander arrêt ou redémarrage :"
            echo
            echo "  rofi -show menu -modi \"menu:rofi-power-menu --choices=shutdown/reboot\""
            echo
            echo "Options disponibles :"
            echo "  --dry-run          Ne pas exécuter l’action sélectionnée mais l’afficher sur stderr."
            echo "  --choices CHOIX    Afficher uniquement les choix sélectionnés dans l’ordre donné."
            echo "                     Utiliser / comme séparateur. Choix disponibles : lockscreen,"
            echo "                     logout, suspend, hibernate, reboot et shutdown. Par défaut,"
            echo "                     tous les choix disponibles sont affichés."
            echo "  --confirm CHOIX    Demander confirmation uniquement pour les choix donnés."
            echo "                     Utiliser / comme séparateur. Choix disponibles : lockscreen,"
            echo "                     logout, suspend, hibernate, reboot et shutdown. Par défaut,"
            echo "                     seules les actions irréversibles logout, reboot et shutdown"
            echo "                     nécessitent une confirmation."
            echo "  --choose CHOIX     Préselectionner le choix donné et ne demander qu’une confirmation"
            echo "                     (si elle est configurée). Il est fortement recommandé de combiner"
            echo "                     cette option avec --confirm=CHOIX si l’action ne demande pas"
            echo "                     de confirmation par défaut. Choix disponibles : lockscreen,"
            echo "                     logout, suspend, hibernate, reboot et shutdown."
            echo "  --[no-]symbols     Afficher ou non les symboles Unicode. Nécessite une police"
            echo "                     compatible (par ex. celles de la collection Nerdfonts)."
            echo "                     Par défaut, ils sont affichés."
            echo "  -h,--help          Afficher ce texte d’aide."
            exit 0
            ;;
        "--dry-run")
            dryrun=true
            shift 1
            ;;
        "--confirm")
            IFS='/' read -ra confirmations <<< "$2"
            check_valid "$1" "${confirmations[@]}"
            shift 2
            ;;
        "--choices")
            IFS='/' read -ra show <<< "$2"
            check_valid "$1" "${show[@]}"
            shift 2
            ;;
        "--choose")
            # Vérifier que le choix est valide
            check_valid "$1" "$2"
            selectionID="$2"
            shift 2
            ;;
        "--symbols")
            showsymbols=true
            shift 1
            ;;
        "--no-symbols")
            showsymbols=false
            shift 1
            ;;
        "--")
            shift
            break
            ;;
        *)
            echo "Erreur interne" >&2
            exit 1
            ;;
    esac
done

# Définir les messages après l’analyse des options de la CLI afin qu’ils puissent
# être configurés à l’avenir.

function write_message {
    icon="<span font_size=\"medium\">$1</span>"
    text="<span font_size=\"medium\">$2</span>"
    if [ "$showsymbols" = "true" ]
    then
        echo -n "\u200e$icon \u2068$text\u2069"
    else
        echo -n "$text"
    fi
}

function print_selection {
    echo -e "$1" | $(read -r -d '' entry; echo "echo $entry")
}

declare -A messages
declare -A confirmationMessages
for entry in "${all[@]}"
do
    messages[$entry]=$(write_message "${icons[$entry]}" "${texts[$entry]^}")
done
for entry in "${all[@]}"
do
    confirmationMessages[$entry]=$(write_message "${icons[$entry]}" "Yes, ${texts[$entry]}")
done
confirmationMessages[cancel]=$(write_message "${icons[cancel]}" "No, cancel")

if [ $# -gt 0 ]
then
    # Si des arguments sont donnés, les utiliser comme sélection
    selection="${@}"
else
    # Sinon, utiliser le choix passé en ligne de commande s’il existe
    if [ -n "${selectionID+x}" ]
    then
        selection="${messages[$selectionID]}"
    fi
fi

# Ne pas autoriser les entrées personnalisées
echo -e "\0no-custom\x1ftrue"
# Utiliser le balisage
echo -e "\0markup-rows\x1ftrue"

if [ -z "${selection+x}" ]
then
    echo -e "\0prompt\x1fPower menu"
    for entry in "${show[@]}"
    do
        echo -e "${messages[$entry]}\0icon\x1f${icons[$entry]}"
    done
else
    for entry in "${show[@]}"
    do
        if [ "$selection" = "$(print_selection "${messages[$entry]}")" ]
        then
            # Vérifier si l’entrée sélectionnée figure dans les confirmations requises
            for confirmation in "${confirmations[@]}"
            do
                if [ "$entry" = "$confirmation" ]
                then
                    # Demander une confirmation
                    echo -e "\0prompt\x1fAre you sure"
                    echo -e "${confirmationMessages[$entry]}\0icon\x1f${icons[$entry]}"
                    echo -e "${confirmationMessages[cancel]}\0icon\x1f${icons[cancel]}"
                    exit 0
                fi
            done
            # Si non, aucune confirmation n’est requise, donc marquer comme confirmé
            selection=$(print_selection "${confirmationMessages[$entry]}")
        fi
        if [ "$selection" = "$(print_selection "${confirmationMessages[$entry]}")" ]
        then
            if [ $dryrun = true ]
            then
                # Indiquer ce qui aurait été fait
                echo "Sélectionné : $entry" >&2
            else
                # Exécuter l’action
                ${actions[$entry]}
            fi
            exit 0
        fi
        if [ "$selection" = "$(print_selection "${confirmationMessages[cancel]}")" ]
        then
            # Ne rien faire
            exit 0
        fi
    done
    # La sélection ne correspond à rien, donc afficher une erreur
    echo "Sélection invalide : $selection" >&2
    exit 1
fi
#+END_SRC

* Source
Cette config viens du projet [[https://github.com/khyrthy/dotfiles][Dotfiles]] de [[https://github.com/khyrthy/dotfiles][Khyrthy]] que nous réutilison et réadapton a i3
